// CUP specification for a simple expression evaluator (w/ actions)

import java_cup.runtime.*;
import java.lang.Number;

parser code {:

public void syntax_error(Symbol cur_token) {
       report_error(String.format("Erreur syntaxique @ l:%03d,c:%03d", cur_token.left, cur_token.right), null);
}

public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
       report_fatal_error("Impossible de continuer l'analyse !", null);
}

:}

terminal PAR_OUV, PAR_FER, PLUS, MOINS, FOIS, DIVISER, MODULO, MOINS_U, VIRGULE, CRO_OUV, CRO_FER, POINT, AROBASE, AFFECT, NL;
terminal EGAL, DIFF, IE, SE, INF, SUP;
terminal ET, OU, NON, OUX, NOU, NET;
terminal ENTIER, GROS_ENTIER, ENTIER_POSITIF, GROS_ENTIER_POSITIF, BOOLEEN, CARACTERE, REEL, ENUMERATION;
terminal CHAINE, TABLEAU, POINTEUR;
terminal SI, ALORS, SINONSI, SINON, FINSI;
terminal POUR, DANS, FAIRE, FINPOUR, TANTQUE, FINTANTQUE;
terminal DEBUT, FIN;

terminal Integer VALENTIER;
terminal Double  VALREEL;
terminal Boolean VALBOOLEEN;

non terminal instructions, instruction;

non terminal Float[] comp;
non terminal Float expr, ternaire;
non terminal Boolean cond;

precedence left PLUS, MOINS;
precedence left FOIS, DIVISER, MODULO;
precedence left MOINS_U;

precedence left INF, SUP;
precedence left IE, SE;
precedence left ET, OU;
precedence left EGAL, DIFF;
precedence left NON;

start with instructions;

instructions ::= 
	  instructions instruction
	| instruction
	;

instruction ::=
	  expr:e NL			{: System.out.println(e); :}
	| comp:c NL			{: System.out.println(String.format("%.1f+%.1fi", c[0], c[1])); :}
	| cond:c NL			{: System.out.println(c); :}
	| ternaire:t NL		{: System.out.println(t); :}
	| error	 			{: System.err.println("Erreur rencontr√©e, l'analyse continue..."); :}
	;

expr 	  ::=
          expr:e1 PLUS expr:e2		{: RESULT = e1 + e2;	  :}    
	| expr:e1 MOINS expr:e2		{: RESULT = e1 - e2;  	  :}    
        | expr:e1 FOIS expr:e2		{: RESULT = e1 * e2;  	  :}    
        | expr:e1 DIVISER expr:e2 	{: RESULT = e1 / e2;  	  :}
	| expr:e1 MODULO expr:e2	{: RESULT = e1 % e2;  	  :}    
        | PAR_OUV  expr:e PAR_FER 		{: RESULT =  e;	      	  :}    
        | MOINS expr:e {: RESULT = -e; :} %prec MOINS_U
	| VALREEL:n     	  	       	{: RESULT =  n;		  :}
        ;

comp	  ::=
	  comp:c1 PLUS comp:c2		{: RESULT = new Float[] { c1[0]+c2[0], c1[1]+c2[1] }; :}
	| comp:c1 MOINS comp:c2		{: RESULT = new Float[] { c1[0]-c2[0], c1[1]-c2[1] }; :}
	| comp:c1 FOIS comp:c2		{: RESULT = new Float[] { c1[0]*c2[0]-c1[1]*c2[1], c1[1]*c2[0]+c1[0]*c2[1] }; :}
	| PAR_OUV  comp:c PAR_FER		{: RESULT = c; :}
	| MOINS comp:c {: RESULT = new Float[] { -c[0], -c[1] }; :} %prec MOINS_U
	| PAR_OUV VALREEL:n1 VIRGULE VALREEL:n2	PAR_FER {: RESULT = new Float[] { n1, n2 }; :}
	;

cond	  ::=
	  cond:c1 ET  cond:c2		{: RESULT = (c1 && c2);   :}
	| cond:c1 OU   cond:c2		{: RESULT = (c1 || c2);   :}
	| expr:e1 IE   expr:e2		{: RESULT = (e1 <= e2);   :}
	| expr:e1 SE   expr:e2		{: RESULT = (e1 >= e2);   :}
	| expr:e1 INF   expr:e2		{: RESULT = (e1 < e2);    :}
	| expr:e1 SUP   expr:e2		{: RESULT = (e1 > e2);    :}
	| cond:c1 EGAL   cond:c2		{: RESULT = (c1 == c2);   :}
	| cond:c1 DIFF cond:c2		{: RESULT = (c1 != c2);   :}
	| PAR_OUV cond:c PAR_FER		{: RESULT =  c;		  :}
	| NON cond:c   			{: RESULT = !c;		  :}
	| VALBOOLEEN:b			{: RESULT =  b; 	  :}
	;

ternaire  ::=
	  cond:c  ALORS expr:e1 SINON expr:e2	{: RESULT = c	    ? e1 : e2;	:}
	| expr:e0 ALORS expr:e1 SINON expr:e2	{: RESULT = (e0!=0) ? e1 : e2;	:}
	;